interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(va
)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 3
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
points = 1000
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = numbers)
values = seq(interval[1], interval[2], length.out = points)
points = 1000
values = seq(interval[1], interval[2], length.out = points)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
points = 1000
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = points)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
points = 1000
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = points)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
View(new_mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
points = 1000
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
points = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
install.packages("caret")
library(cated)
library(caret)
a = 1:10
b = createFolds(a, 3)
b
library(caret)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
number = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = number, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
# c.
distributedNumbers = createFolds(points, 3)
distributedNumbers
distributedNumbers = createFolds(points[,2], 3)
distributedNumbers = createFolds(points[,2], 3)
distributedNumbers
View(points)
View(points)
View(points)
library(caret)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
number = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = number, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
# c.
y = points[,2]
distributedNumbers = createFolds(y, 3)
distributedNumbers
library(caret)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
number = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = number, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
# c.
y = points[,2]
distributedNumbers = createFolds(y, 3)
distributedNumbers
y
distributedNumbers = createFolds(c(1, 2, 3, 6, 5, 12, -324, 2, 0), 3)
distributedNumbers
distributedNumbers = createDataPartition(y, 3)
distributedNumbers
distributedNumbers = createResample(y, 3)
distributedNumbers
distributedNumbers = createFolds(y, 3)
distributedNumbers
distributedNumbers = createFolds(y, 10)
distributedNumbers
sample(y)
y
x = points[,1]
xgroups = matrix(data = x, nrow = 3)
xgroups
View(xgroups)
View(xgroups)
xgroups = matrix(data = x, nrow = 10)
xgroups = matrix(data = sample(x), nrow = 10)
xgroups = matrix(data = sample(x), nrow = 10)
xgroups = matrix(data = sample(x), nrow = 10)
xgroups = matrix(data = sample(x), nrow = 10)
xgroups = matrix(data = sample(x), nrow = 10)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
polyFit = function(x, y, degree) {
return(lm(y ~ poly(x, degree)))
}
# configuration
set.seed(20)
degree = 0
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
number = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = number, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
# c.
x = points[,1]
y = points[,1]
for (i in 1:10) {
xgroups = matrix(data = x, nrow = 3)
}
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
polyFit = function(x, y, degree) {
return(lm(y ~ poly(x, degree)))
}
# configuration
set.seed(20)
degree = 4
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
number = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = number, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
createRandomPointsWithErrorsForTargetFunction = function(numberOfPoints, interval) {
x = runif(numberOfPoints, interval[1], interval[2])
y = 2 + x - 0.5 * x ^ 2
errors = rnorm(n = numberOfPoints, mean = 0, sd = 0.4)
ywitherrors = y + errors # adding errors to the function values
return(matrix(c(x, ywitherrors),ncol = 2, nrow = length(x)))
}
mse = function(points, func, numbers) {
return(sum((points - func) ^ 2) / numbers)
}
# configuration
set.seed(20)
degree = 8
interval = c(-3, 3)
points = 30
points = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = points[,1]
y = points[,2]
plot(x, y, pch=16)
# creating model with the give degree
regression = lm(y ~ poly(x, degree))
values = seq(from = interval[1], to = interval[2], by = 0.1)
model = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
# adding mode to the plot
lines(values, model[,1], col='green', lwd=5)
mse_value = mean(regression$residuals^2)
sprintf("MSE: %f", mse_value)
# task 2
points = 1000
values = createRandomPointsWithErrorsForTargetFunction(numberOfPoints = points, interval)
x = values[,1]
y = values[,2]
points(x = x, y = y, col="red")
values = seq(interval[1], interval[2], length.out = number)
newprediction = predict(regression, data.frame(x = values), interval = "confidence", level = 0.95)
new_mse_value = mse(points = newprediction[,1], func = y, numbers = points)
sprintf("MSE: %f", new_mse_value)
